package{ 	import flash.display.Sprite ;	import flash.events.MouseEvent ;	import flash.events.Event ;	import flash.utils.Timer ; 	import flash.events.TimerEvent ;		import gs.TweenLite ;			public class HStack extends Sprite	{		private var _stackOpen		: Boolean = false;				private var _openTime		: Number = 3 ;		private var _closeTime		: Number = .5 ;		private var _offset			: Number = 5 ;		private var _clipArray		: Array ;		private var _clipWidth		: Array = [ 0 ] ;	// the array is init with a an index of one to calculate the width for all clips****trick******		private var _storyNum		: Number = -1 ;		// XML node to be called 		private var _file 			: String ;		private var _xDistance		: Number = 0 ;		private var _clipLoaded		: Boolean = false ;		private var _timer			: Timer ;		private var _closeDelay		: Number = 750 ; // in MS 				private var _xmlThumbID		: String  = "thumb" ;		private var _xmlImgID		: String  = "source" ;						public function set xmlThumbID ( $id:String ):void	{ _xmlThumbID = $id }				public function set xmlImgID ( $id:String ):void	{ _xmlImgID = $id }						public function set offset ( $offset:Number ):void		{ _offset = $offset  }				public function set openSpeed ( $time:Number ):void		{ _openTime = $time  }				public function set closeSpeed ( $time:Number ):void 	{ _closeTime = $time }				public function set xml ( $url:String ):void	{ _file = $url }				public function set story ( $story: uint ):void	{ _storyNum = $story }			public function set closeDelay ( $num: Number ):void	{ _closeTime = $num }						public function HStack() { init() }				public function load():void											{									if ( _file == null ) 	{ throw new Error ( "Error: Set a URL for the XML file. Use 'myStack.xml' ") } 			if ( _storyNum == -1 ) 	{ throw new Error ( "Error: Set a story number ( xml node ) to load. Use 'myStack.story' ") } ;						if ( !_clipLoaded )   // if this is the first time loading continue the load			{   				_beginLoad() ;			}			else              // else unload the current clips, reset and load new ones			{				_xDistance = 0 ;								_clipWidth = [ 0 ] ;								TweenLite.to(this, .35, { alpha:0, onComplete:_unloadClips } ) ;								_unloadClips () ;			}		}					private function init():void		{			this.addEventListener ( MouseEvent.MOUSE_OVER, _openStack, false, 0, true ) ;			this.buttonMode = true ;						_startHitTestTimer() ;		}				private function _beginLoad():void															{																								var stackXML 		= new StackXML() ;		   	stackXML.xml 		= _file ;		   	stackXML.story 		= _storyNum ;			stackXML.xmlThumbID = _xmlThumbID ;			stackXML.xmlImgID 	= _xmlImgID ;		   			 	stackXML.load() ;													   	stackXML.addEventListener ( Event.COMPLETE, _getArrayFromXML, false,0,true)	;		// listens for event from StackXML		}				private function _getArrayFromXML($evt:Event):void		{			$evt.target.removeEventListener ( Event.COMPLETE, _getArrayFromXML ) ;						_clipArray = $evt.target.images ;			_clipArray [ 0 ].contentLoaderInfo.addEventListener ( Event.INIT, _startMe, false, 0, true ) ;  // fades in stack when it loads						_addClips() ;		}				private function _startMe($evt:Event):void                            					   	// fade in the the clip when loaded		{			$evt.target.removeEventListener ( Event.INIT, _startMe ) ;						TweenLite.to ( _clipArray [ 0 ], 1, { alpha:.5 } ) ;		}				private function _addClips():void		{			_clipLoaded = true						var i:uint = 0						var ii:uint = 1						var l:uint = _clipArray.length ;						for ( i ; i < l ; i++ )			{				_clipArray [ i ].alpha = 0 ;				_clipArray [ i ].scaleX = _clipArray [ i ].scaleY = .75  ;       // sclaes down clip so it is scaled up on roll over				addChild ( _clipArray [ l - ii ])    ;						     		// adds Clips in reverse order for proper depth 								      										ii++ ;			}		}				private function _unloadClips():void		{					var i : Number = 0 ;			var l : uint = _clipArray.length ;						for ( i ; i < l ; i++ )			{				removeChild ( _clipArray [ i ] ) ; 			}						if ( i == l ) 			{				_clipLoaded = false ;							} 											TweenLite.to ( this, .25, { alpha:1, onComplete:_beginLoad } ) ;		}		private function _openStack($evt:MouseEvent):void		{			this.removeEventListener ( MouseEvent.MOUSE_OVER, _openStack ) ;			var i : Number = 0 ;			var l : uint = _clipArray.length ;						for ( i ; i < l ; i++ )			{						_figureX ( i );								if ( i != _clipArray.length-1 )				{					TweenLite.to ( _clipArray [ i ], .4, { autoAlpha:.4, x:_clipWidth [ i ] } ) ;				}				else				{					TweenLite.to ( _clipArray [ i ], .4, { autoAlpha:.4, x:_clipWidth [ i ], onComplete:_onOpenFinish } ) ;				}							}		}				private function _figureX ( $num:Number ):void 					{										_xDistance += _clipArray [ $num ].width + _offset ;     // dynamicly calculates the width of the stack then adds the offset 			_clipWidth.push ( _xDistance ) ;		}				private function _closeStack():void		{					var i : uint = 0			var l : uint = _clipArray.length ;						for ( i ; i < l ; i++)			{					_clipArray [ i ].removeEventListener ( MouseEvent.MOUSE_OVER, 	_childMouseOver ) ;				_clipArray [ i ].removeEventListener ( MouseEvent.MOUSE_OUT, 	_childMouseOut ) ;				_clipArray [ i ].removeEventListener ( MouseEvent.MOUSE_DOWN, 	_childOnClick ) ;								if ( i == 0 )				{					TweenLite.to ( _clipArray [ i ], .5, { autoAlpha:.5, x:0, scaleX:.75, scaleY:.75 } ) ;				}				else if ( i == ( l-1 ) )				{					TweenLite.to ( _clipArray [ i ], .6, { x:0, autoAlpha:0,scaleX:.75,scaleY:.75, onComplete:_onCloseFinish } ) ;				}				else				{					TweenLite.to ( _clipArray [ i ], .5, { autoAlpha:0, x:0, scaleX:.75, scaleY:.75 } ) ;				}					                                                                        			}		                                                                                                                                                 		}				private function _onCloseFinish():void		{			this.addEventListener ( MouseEvent.MOUSE_OVER, _openStack ) ;						}				private function _onOpenFinish():void		{			var i : uint = 0 ;			var l : uint = _clipArray.length ;						for ( i ; i < l ; i++ )			{						_clipArray [ i ].addEventListener ( MouseEvent.MOUSE_OVER, 	_childMouseOver,	false, 0, true)				_clipArray [ i ].addEventListener ( MouseEvent.MOUSE_OUT, 	_childMouseOut, 	false, 0, true)				_clipArray [ i ].addEventListener ( MouseEvent.MOUSE_DOWN, 	_childOnClick, 		false, 0, true) 			}		}				private function _childMouseOver($evt:MouseEvent):void		{			TweenLite.to ( $evt.target, .4,{alpha:1,scaleX:1,scaleY:1})		}				private function _childMouseOut($evt:MouseEvent):void		{			TweenLite.to ( $evt.target, .5,{alpha:.4,scaleX:.75,scaleY:.75})		}		private function _childOnClick($evt:MouseEvent):void		{			//Object(root).loadImage2($evt.target.name);			$evt.target.dispatchEvent ( new Event ( Event.ACTIVATE) ) ;		}			 	private function _startHitTestTimer() :void        {            _timer = new Timer ( _closeDelay , 0 );            _timer.addEventListener ( TimerEvent.TIMER, _onTick );			_timer.start () ;        }        private function _onTick ( $evt:TimerEvent ):void         {				if( mouseY > this.height || mouseY < 0 )			{				_closeStack() ;			}        }	}}