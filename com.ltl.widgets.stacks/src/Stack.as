package {	import gs.TweenGroup;	import com.greensock.TweenLite;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.utils.Dictionary;		public class Stack extends Sprite 	{		public static const THUMB_CLICKED : String = "THUMB_CLICKED";		public var thumbBuffer : Number = 10;		public var openSpeed : Number = .35;		public var fileNameofBigImageToLoad : String;		private var stackOpenHitArea : Sprite = new Sprite();		private var stackData : StackVO;		private var myGroup : TweenGroup;		private var hitAreaWidth : Number;		private var largeImageURLKeys : Dictionary;		private var myGroup2 : TweenGroup;		public function Stack(stackData : StackVO) 		{			this.stackData = stackData;			createThumbTweens();		}		// thumbs are initialized at their open X value and alpha 1.		// this is b/c the stack roll over/out events are acutally just running the tweens backwards each time.		private function createThumbTweens() : void		{			myGroup = new TweenGroup();						var openX : Number = stackData.previewImg.width + thumbBuffer;			for (var i : int = 0;i < stackData.stackItemVOs.length;i++) 			{				var target : Sprite = StackItemVO(stackData.stackItemVOs[i]).thumbImage;				target.x = openX;				target.alpha = 1;				target.buttonMode = true;								myGroup.push(TweenLite.to(target, openSpeed, {x:0, alpha:0}));				openX += target.width + thumbBuffer;			}						myGroup.progress = 1;			myGroup.pause();			// save for later			hitAreaWidth = openX;			createPreviewTweens();		}		private function createPreviewTweens() : void		{			myGroup2 = new TweenGroup();			stackData.previewImg.alpha = 0;			stackData.stackActiveImg.alpha = 1;			myGroup2.push(TweenLite.to(stackData.previewImg, openSpeed,{alpha:1}));			myGroup2.push(TweenLite.to(stackData.stackActiveImg, openSpeed,{alpha:0}));			myGroup2.progress = 1;			createHitArea();		}		private function createHitArea() : void		{			stackOpenHitArea.graphics.beginFill(0xff0000, .5);			stackOpenHitArea.graphics.drawRect(0, 0, hitAreaWidth, stackData.previewImg.height);			stackOpenHitArea.graphics.endFill();			stackOpenHitArea.visible = false;			addAllToDisplayList();		}		private function addAllToDisplayList() : void		{			addChild(stackOpenHitArea);			for each (var stackItem : StackItemVO in stackData.stackItemVOs) 			{				addChild(stackItem.thumbImage);			}			addChild(stackData.previewImg);			addChild(stackData.stackActiveImg);						addEventListeners();		}		private function addEventListeners() : void		{			this.addEventListener(MouseEvent.ROLL_OVER, openStack);						for each (var stackItem : StackItemVO in stackData.stackItemVOs) 			{				stackItem.thumbImage.addEventListener(MouseEvent.CLICK, loadParentImage);			}						createThumbClickKeys();		}		private function createThumbClickKeys() : void		{			largeImageURLKeys = new Dictionary(true);			for each (var stackItem : StackItemVO in stackData.stackItemVOs) 			{				largeImageURLKeys[stackItem.thumbImage] = stackItem.largeImgURL;			}		}				private function openStack(event : MouseEvent) : void		{			myGroup2.reverse();			this.removeEventListener(MouseEvent.ROLL_OVER, openStack);			this.addEventListener(MouseEvent.ROLL_OUT, closeStack);						stackOpenHitArea.visible = true;			myGroup.reverse();		}		private function closeStack(event : MouseEvent) : void		{			myGroup2.reverse();			this.removeEventListener(MouseEvent.ROLL_OUT, closeStack);			this.addEventListener(MouseEvent.ROLL_OVER, openStack);						stackOpenHitArea.visible = false;			myGroup.reverse();		}		private function loadParentImage(event : MouseEvent) : void		{			trace(this, ' ::: @ loadParentImage ', 'event = ' + (event));			fileNameofBigImageToLoad = String(largeImageURLKeys[event.currentTarget]);			dispatchEvent(new Event(Stack.THUMB_CLICKED));		}	}}