stop();_global.pfroot = _parent.pageflip;XMLfn = "./xml/data.xml";trace('this = '+ this);//do not change these variables: ------------------------------------------------------------------_global.mcnt = 0;	//countergpage = 0;			//gotoPage Nogflip = false;		//gotoPage flipgdir = 0;			//goto direction...gskip = false;		//skip pages	***gtarget = 0;		//target when skippingaflip = false;		//auto flipflip = false;		//pageflipflipOff = false;	//terminateflipflipOK = false;		//good fliphflip = false;		//hardflip (the cover of the book)pgmaskh = ph;preflip = false;	//corner flip statusctear = false;		//actual page statustear = false;teard = 0;overbutton = false;removedPages = new Array();	//list of removed pages!mpx = 0, mpy = 0;	//mousepos at clicksx = sy = 0;		//startpoint when flippingx = 0;				//mouse x,yy = 0;ax = 0;				//auto x,yay = 0;acnt = 0;aadd = 0;aamp = 0;op0 = op1 = op2 = op3 = op4 = op5 = 0;np0 = np1 = np2 = np3 = np4 = np5 = 0;pagesOffsetX = 0;	//Used for center single page animationpagesTargetX = 0;CenterAnimation = false;	CenterAnimActive = false;CenterAnimDir = 0;AM = Math.PI/180;directlink = _root.directlink;	//linking to a page from html embed levelif(directlink == undefined) directlink = -1;//function definitions-----------------------------------------------------------------------------			function reset(maxpage) {			//initializing pages... -------------------------------			pageNumber = new Array();			for(var i=0;i<=(maxpage+1);i++) pageNumber[i] = i;		}				mousecontroll = new Object();		//initializing mouse click handler --------------------		mousecontroll.onMouseDown = function() {			if(!aflipstat) {				if(flip && !aflip) {//  && !preflip) {					flipOK = false;						if(sx<0 && pages._xmouse>0) flipOK = true;					if(sx>0 && pages._xmouse<0) flipOK = true;					flipOff = true;					flip = false;				} else if((flipOff || aflip || !canflip) && !preflip) {					//do nothing!				} else if(!preflip) {					var oox = ox;					var ooy = oy;					var osx = sx;					var osy = sy;				} else {	//if preflipping				//	startsnd(1);		//Sound					onFlipStart(page,"PAGECLICK");	//Event Handler ****					//anim._visible = false;					flip = true;					flipOff = false;					tear = false;			//not tearing yet...					aflip = preflip = false;					mpx = pages._xmouse, mpy = pages._ymouse;					oef();				}			}		}		mousecontroll.onMouseUp = function() {			if(!aflipstat) {				if(flip && !tear) {					if(Math.abs(pages._xmouse-mpx)<afa || preflip) {						flip = false;						preflip = false;						//aflip = true;						autoflip();					//	startsnd(2);			//sound						//trace("MOUSE UP, FLIP!");					} else if(!preflip) {						flipOK = false;							if(sx<0 && pages._xmouse>0) flipOK = true;						if(sx>0 && pages._xmouse<0) flipOK = true;						flipOff = true;						flip = false;					//	if(flipOK) startsnd(2);	//sound					} 				} else {					//trace("new zoom check");					if(ZoomOnPageClick && !overbutton && pagehittest() && !(flipOff || aflip || !canflip) && !preflip) {						//trace("NEEEEEEW ZOOOOOOOOOOOOOOOOOM");						//if no button mouseover on any page let's show the zoom						var zoompage = page+(pages._xmouse>=0?1:0);						showZoom(zoompage);					}				}			}					}		function removeML() {	//removes mouse listener								//Call this function before unloading the pageflip								//if you don't do that, the next time you load a								//pageflip, the mouselistener will not work!			Mouse.removeListener(mousecontroll);			}		this.onUnload = function() {			removeML();		}		function pagehittest() {			trace('pagehittest');			var x=pages._xmouse;			var y=pages._ymouse;			var pmh = ph/2;						var xadd = isCover(x)?coverSide:0;			var tadd = isCover(x)?coverTop:0;			var badd = isCover(x)?coverBottom:0;								if(y<=(pmh+badd) && y>=-(pmh+tadd) && x<=(pw+xadd) && x>=-(pw+xadd)) {	//ha a megadott intervallumban klikkelunk, akkor lapozhatunk				return true;			}			return false;		}				function hittest() {	//hittest at mouse clicks, if click is over the book -> determining turning direction ------------------------------------			var x=pages._xmouse;			var y=pages._ymouse;			var pmh = ph/2;						var xadd = isCover(x)?coverSide:0;			var tadd = isCover(x)?coverTop:0;			var badd = isCover(x)?coverBottom:0;			pgmaskh = isCover(x)?coverBottom+coverTop+ph:ph;								if(y<=(pmh+badd) && y>=-(pmh+tadd) && x<=(pw+xadd) && x>=-(pw+xadd)) {	//ha a megadott intervallumban klikkelunk, akkor lapozhatunk				if(x>pw) x = pw;				if(x<-pw) x = - pw;				if(y>pmh) y = pmh;				if(y<-pmh) y = - pmh;				var r = Math.sqrt(x*x+y*y);				var a = Math.asin(y/r);				var y = Math.tan(a)*pw;				oy = sy = y;				r0 = Math.sqrt((sy+ph/2)*(sy+ph/2)+pw*pw);				r1 = Math.sqrt((ph/2-sy)*(ph/2-sy)+pw*pw);				//trace("HITTEST page:"+page);				if(x<-(pw-clickarea) && page>gminpage) {		//page>0) {	//>-----> flip backward					hflip = checkCover(page,-1);					setPages(page-2,page-1,page,page+1);					offs = -pw;					fmask._x = pw;					ctear = p[pageNumber[page]].tear;					return -1;				}				if(x>(pw-clickarea) && page<gmaxpage-1) {	//<-----< flip forward					hflip = checkCover(page,1);					setPages(page,page+2,page+1,page+3);					offs = 0;					fmask._x = 0;					ctear = p[pageNumber[page+1]].tear;					return 1;				}			} else return 0;	//wrong click		}		function isCover(x) {			if(x<0) return p[pageNumber[page]].isCover;			if(x>0) return p[pageNumber[page+1]].isCover;		}		function checkCover(page,dir) {			if(hcover) {				if(dir>0) {					if(page==(maxpage-2) || page==0) return true;				} else {					if(page==maxpage || page==2) return true;				}			}			if(dir>0) return (hardpage || p[pageNumber[page+1]].isHard);				else return (hardpage || p[pageNumber[page]].isHard);			}		function corner() {			var x = Math.abs(pages._xmouse);			var y = Math.abs(pages._ymouse);			if(x>(pw-afa) && x<pw && y>(ph/2-afa) && y<(ph/2) && !aflipstat && pages._ymouse > 0) {				hide_nav();				return true;			}			show_nav();			return false;					}				function hide_nav(){					}		function show_nav(){					}		function oef() {			//trace("-------------> "+pfroot.preflip+" "+pfroot.flip+" "+pfroot.aflip);			_global.mcnt++;	//main counter incrase (need for some page effect);			if(!flip && corner()) {	//corner mouseover				preflip = true;				fmask._x = pw;				if(!autoflip()) preflip = false;			}			if(preflip && !corner()) {				preflip = false;				preflipend = true;				flip = false;				flipOK = false;				flipOff = true;			}			getm();			if(aflip && !preflip) {				y = (ay += (sy-ay)/(gflip? gs: ps ));				acnt += aadd;				ax -= aadd;				if(Math.abs(acnt)>pw) {					flipOK = true;					flipOff = true;					flip = false;					aflip = false;				}			}			if(flip) {							//page turning is in progress...				if(tear) {					x = tox;					y = (toy += teard);					teard *= 1.2;					if(Math.abs(teard)>1200) {						flipOff = true;						flip = false;					}				} else {					x = (ox += (x-ox)/(gflip? gs: ps ));					y = (oy += (y-oy)/(gflip? gs: ps ));				}				calc(x,y);						//positioning pages and shadows			}			if(flipOff) {						//terminating page turning effect... (comlplete turning... dropped on the other side)				if(flipOK || tear) {					x = (ox += (-sx-ox)/(gflip? gs: es ));					y = (oy += (sy-oy)/(gflip? gs: es ));					calc(x,y);					if(x/-sx > 0.99 || tear) {			//we are done with turning, so stop all turning issue...						flip = false;						flipOK = flipOff = false;						//_quality = "BEST";	//if quality is decrased during turning effect, you must reset its default value!								if(tear) {				//if tear: remove page!!!							removePage((sx<0)? page: page+1);							page += (sx<0)? -2: 0;							onTearOut(page, "SUCCESS");		//Event handler ****						} else {							page += (sx<0)? -2: 2;	//and tourning pages at pagenumber level...						}						flipend();						if(gskip) page = gtarget;						setPages(page,0,0,page+1);						if(!tear) onFlipEnd(page, "SUCCESS");	//Event handler ****						tear = false;												if(gpage>0 && !gskip) {			//gotoflip active -> is there another flipping left?							gpage--;							autoflip();						//	startsnd(0);	//sound						} else gflip = gskip = false;					}				} else {						//terminating page turning effect... (incomlplete turning... dropped on the dragged side)					x = (ox += (sx-ox)/3);					y = (oy += (sy-oy)/3);					calc(x,y);					if(x/sx > 0.99) {			//we are done with turning, so stop all turning issue...						flip = false;						flipOff = false;						aflip = false;						//pgrad._visible = pages.pp2._visible = pages.pp3._visible = false;						//_quality = "HIGH"; 	//if quality is decrased during turning effect, you must reset its default value!						if(!preflipend) onFlipEnd(page, "FAULT");		//Event handler ****						preflipend = false;						flipend();						setPages(page,0,0,page+1);	//no change at pagenumbers..							}				}			}						//CenterAnimation			/*			pagesOffsetX = 0;	//Used for center single page animation			pagesTargetX = 0;			CenterAnimation = false;			*/						if(CenterAnimation && CenterSinglePage) {				if(CenterAnimDir<0) {					if(x>0) x = 0;					if(x<-pw) x = -pw;					pagesOffsetX = -pw/2 - x/2;				} else {					if(x<0) x = 0;					if(x>pw) x = pw;					pagesOffsetX = pw/2 - x/2;				}				setPagesX();			}								}						function calc(x,y) {	//positioning pages and shadows by x,y reference points while flipping -------------------------------			//trace("   CALC x/y "+x+"/"+y);			if(hflip) {						//hardflip...				var xp = (sx<0)? -x: x;				if(xp>0) {					//right side					hp2._visible = false;					hp3._visible = true;					scalc(hp3,x,pw/2-hit*pw/2);				} else {					//left side					hp3._visible = false;					hp2._visible = true;					scalc(hp2,x,pw/2+hit*pw/2);				}				pp2.setMask(null);			//hard flipping don't needs any mask				pp3.setMask(null);				fgrad._visible = false;		//nor shadow projected on it				return;			} else fgrad._visible = true;	//normal flipping needs projected shine/shadow effect						//normal flipping process---------------------------------------------------------------------						//calculating position/rotation/masking of the flipping page 			var rr0 = Math.sqrt((y+ph/2)*(y+ph/2)+x*x);			var rr1 = Math.sqrt((ph/2-y)*(ph/2-y)+x*x);			if((rr0>r0 || rr1>r1) && !tear) {	// we can tear off pages now:)												// so reference points must be recalculated!				if(y<sy) {						// k1-gyel kell osszehasonlitani!					var a = Math.asin((ph/2-y)/rr1);					y = (ph/2-Math.sin(a)*r1);					x = (x<0)? -Math.cos(a)*r1: Math.cos(a)*r1;					if(y>sy) {						if((sx*x)>0) y = sy, x = sx;						else y = sy, x = -sx;					}					if((rr1-r1)>tlimit && ctear) {						teard = -5;						tear = true;						tox = ox = x;						toy = oy = y;					//	startsnd(3);					}				} else {						// k0-val kell osszehasonlitani!					var a = Math.asin((y+ph/2)/rr0);					y = Math.sin(a)*r0-ph/2;					x = (x<0)? -Math.cos(a)*r0: Math.cos(a)*r0;					if(y<sy) {						if((sx*x)>0) y = sy, x = sx;						else y = sy, x = -sx;					}					if((rr0-r0)>tlimit && ctear) {						teard = 5;						tear = true;						tox = ox = x;						toy = oy = y;					//startsnd(3);					}				}			}			if((sx<0 && (x-sx)<10) || (sx>0 && (sx-x)<10)) {				if(sx<0) x = -pw+10;				if(sx>0) x = pw-10;			} 			//calculating flipping process			p3shadow._visible = pgrad._visible = !tear;			pp2._visible = pp3._visible = true;			//equation of the line			var vx = x-sx;			var vy = y-sy;			var a1 = vy/vx;			var a2 = -vy/vx;						cx = sx+(vx/2);			cy = sy+(vy/2);			//trigonometriai szamitasok			//calculating rotation of the page, and the masks			var r = Math.sqrt((sx-x)*(sx-x)+(sy-y)*(sy-y));			var a = Math.asin((sy-y)/r);			if(sx<0) a = -a;				ad = a/AM; 	//in degree			pageN._rotation = ad*2;			//r = Math.sqrt((sx-x)*(sx-x)+(sy-y)*(sy-y));			rl = (pw*2);			var scl = (r/rl/2)*pw;			if(sx>0) { 											//flip forward				pages.mask0._xscale = pages.mask1._xscale = 100;				nx = cx-Math.tan(a)*(ph/2-cy);				ny = ph/2;				if(nx>pw) {					nx = pw;					ny = cy+Math.tan(Math.PI/2+a)*(pw-cx);				}				pageN.pf._x = -(pw-nx);				fgrad._xscale = scl;				pgrad._xscale = -scl;				p3shadow._xscale = scl;			} else { 											//flip backward				pages.mask0._xscale = pages.mask1._xscale = -100;				nx = cx-Math.tan(a)*(ph/2-cy);				ny = ph/2;				if(nx<-pw) {					nx = -pw;					ny = cy+Math.tan(Math.PI/2+a)*(-pw-cx);				}				pageN.pf._x = -(pw-(pw+nx));				fgrad._xscale = -scl;				pgrad._xscale = scl;				p3shadow._xscale = -scl;			}			pages.mask0._x = pages.mask1._x = cx;			pages.mask0._y = pages.mask1._y = cy;			pages.mask0._rotation = pages.mask1._rotation = ad;			pageN.pf._y = -ny;			pageN._x = nx+offs;			pageN._y = ny;			fgrad._x = cx;			fgrad._y = cy;			fgrad._rotation = ad;			var av = (r>(rl-50))? 100-(r-(rl-50))*2: 100;			fgrad._alpha = av;			p3shadow._x = cx;			p3shadow._y = cy;			p3shadow._rotation = ad;			p3shadow._alpha = av;			pgrad._x = cx;			pgrad._y = cy;			pgrad._rotation = ad+180;			pgrad._alpha = av;						fmask.page._x = pageN._x;			fmask.page._y = pageN._y;			fmask.page.pf._x = pageN.pf._x;			fmask.page.pf._y = pageN.pf._y;			fmask.page._rotation = pageN._rotation;		}				function scalc(obj,x,offs) {	//hardflip calc			x = Math.round(x);			if(x<-pw) x=-pw;			if(x>pw) x=pw;			var a = Math.asin( x/pw );			var rot = a/AM/2;			var xs = 100;			var ss = 100*Math.sin( rotz*AM );			x = x/2-pw;			var y = Math.cos(a)*(pw/2)*(ss/100);			placeImg(obj, rot, ss, x, y, offs);			pgrad._visible = true;			pgrad._xscale = x+pw;			pgrad._alpha = p3shadow._alpha = 100;			p3shadow._xscale = -x+pw;			p3shadow._x = 0;			p3shadow._y = 0;			p3shadow._rotation = 0;			pgrad._x = 0;			pgrad._y = 0;			pgrad._rotation = 0;		}				function placeImg(j, rot, ss, x, y, offs) {			var m = Math.tan( rot*AM );			var f = Math.SQRT2/Math.sqrt(m*m+1);			var phxs = 100*m;			var phRot = -rot;;			var xs = 100*f;			var ys = 100*f;			j.ph.pic.pic._x = -pw/2;			j.ph.pic._rotation = 45;			j.ph.pic._xscale = (phxs<0)? - xs: xs;			j.ph.pic._yscale = ys*(100/ss);			//trace(xs+" "+phxs);			j.ph._rotation = phRot;			j.ph._xscale = phxs;			j._yscale = ss;			if(offs>0) offs+=2;			else offs-=2;			j._x = x+pw+offs;			j._y = y;			j._visible = true;		}				function setPages(p1,p2,p3,p4) {	//set page visibilities						//new pages to display				np1 = p1;				np2 = p2;				np3 = p3;				np4 = p4;												if(np1<0) np1=0;	//available pages				if(np2<0) np2=0;				if(np3<0) np3=0;				if(np4<0) np4=0;				if(np4>maxpage) np4=0;								var noFlip = (np2==0&&np3==0);	//are there any active flipping?			//	trace("noFlip "+noFlip);								//trace("setpages -> "+np1+","+np2+","+np3+","+np4);							if(CenterSinglePage) {						//set up center animation								if(np2==0 && np3==0) {									CenterAnimation = false;			//** no animation									if(np1==0 || np4==0) {				//place to center										if(np1==0) pagesOffsetX = -pw/2;										else pagesOffsetX = pw/2;									} else pagesOffsetX = 0;									setPagesX();								}								if(np1==0 || np4==0) {									if(np2 && np3) {					//** center animation enabled										CenterAnimation = true;										if(np1==0) CenterAnimDir = -1										else CenterAnimDir = 1;									}								}							}														if(BackContent) {			//back content control								var bv = (p1<=2 | p4>maxpage-2) ;								var bt = (p1<2 | p4>maxpage);								//trace("BACK VISIBLE: "+bv+" onTop:"+bt);								pages.back.reset(bt, bv&BackActive);								backVisible(bv|BackAlwaysVisible);																//Set the background in the BackContent								if(np1==0) pages.back.setBack(np4==0?-1:0);								else if(np4==0) pages.back.setBack(2);								else pages.back.setBack(1);							}																//disable old pages				p[pageNumber[op1]].item._visible = false;				p[pageNumber[op1]].page.reset(false,false);				p[pageNumber[op2]].item._visible = false;				p[pageNumber[op2]].page.reset(false,false);				p[pageNumber[op3]].item._visible = false;				p[pageNumber[op3]].page.reset(false,false);				p[pageNumber[op4]].item._visible = false;				p[pageNumber[op4]].page.reset(false,false);				if(transparency) {					p[pageNumber[op0]].item._visible = false;					p[pageNumber[op0]].page.reset(false,false);					p[pageNumber[op5]].item._visible = false;					p[pageNumber[op5]].page.reset(false,false);				}				if(lcover) {					opl0 = 2;					opl1 = maxpage-1;										p[pageNumber[opl0]].item._visible = false;					p[pageNumber[opl0]].page.reset(false,false);					p[pageNumber[opl1]].item._visible = false;					p[pageNumber[opl1]].page.reset(false,false);				}							p[pageNumber[np1]].item._visible = true;				p[pageNumber[np2]].item._visible = true;				p[pageNumber[np3]].item._visible = true;				p[pageNumber[np4]].item._visible = true;								p[pageNumber[np1]].item.swapDepths(11);				p[pageNumber[np2]].item.swapDepths(23);				p[pageNumber[np3]].item.swapDepths(20);				p[pageNumber[np4]].item.swapDepths(10);								p[pageNumber[np1]].page.reset(true,false,noFlip);				p[pageNumber[np2]].page.reset(true,false);				p[pageNumber[np3]].page.reset(true,false);				p[pageNumber[np4]].page.reset(true,false,noFlip);								var poff = new Array();				for(var i=1;i<5;i++) {					poff[i] = this["np"+i];				}				for(var i=1;i<5;i++) {					var present = false;					for(var j=1;j<5;j++) {						if(this["op"+i] == poff[j]) present = true;					}					if(!present) {						//trace("page "+this["op"+i]+" is not visible anymore");						p[pageNumber[this["op"+i]]].page.reset(false,false);					}				}								op1 = np1;				op2 = np2;				op3 = np3;				op4 = np4;								if(lcover) {					//if the largcover feature is enabled, then we need to keep the inside covers visible when needed.					if(np1>opl0) {// || np2>0) {						p[pageNumber[opl0]].item._visible = true;						p[pageNumber[opl0]].item.swapDepths(7);						p[pageNumber[opl0]].page.reset(false,false);					} else {						//p[pageNumber[2]].item._visible = false;					}					if(((np4<opl1 && np4>0)  )) {	// || (np3<=maxpage && np3>0)) && np2<=maxpage) {						p[pageNumber[opl1]].item._visible = true;						p[pageNumber[opl1]].item.swapDepths(6);						p[pageNumber[opl1]].page.reset(false,false);					} else {						//p[pageNumber[maxpage-1]].item._visible = false;					}				}				if(transparency) {					np0 = np1-2;						//pages for transparency...					np5 = np4+2;										if(np0>2) {						p[pageNumber[np0]].item._visible = true;						p[pageNumber[np0]].item.swapDepths(9);						p[pageNumber[np0]].page.reset(false,transparencyAct);					}					if(np5<maxpage && np5>2) {						p[pageNumber[np5]].item._visible = true;						p[pageNumber[np5]].item.swapDepths(8);						p[pageNumber[np5]].page.reset(false,transparencyAct);					}										op0 = np0;					op5 = np5;				}							pgrad.swapDepths(19);				pgmask._height = pgmaskh;				p3shadow.swapDepths(21);												pageN.pf._x = 0;				pageN.pf._y = 0;				pageN._x = -pw;				pageN._y = 0;				pageN._rotation = 0;								pageN = p[pageNumber[np2]].item.page;	//eval("pages.flip.p2.page");				pageO = p[pageNumber[np3]].item;		//eval("pages.flip.p3");				pp2 = p[pageNumber[np2]].item;				pp3 = pageO;				hp2 = pp2.page.pf.sph;					//hardpage				hp3 = pp3.page.pf.sph;												ctrl.setpager();				//if(page!=lpage) 				if(pagesready) startPageLoading();	//page loadeing on demand		}		function resetPages() {			setPages(page,0,0,page+1);		}					function autoflip(calcpos) {								//start auto flip!			if(calcpos==undefined) calcpos=true;			if(!aflip && !flip && !flipOff && canflip) {	//only when all conditions fits our needs...				if(calcpos) {					acnt = 0					aamp = Math.random()*(ph/2)-(ph/4);					var x= gflip? (gdir*pw)/2: ((pages._xmouse<0)? -pw/2: pw/2);					var y = Math.random()*(ph/2)-(ph/4);					if(y<0) y-=(ph/8);					if(y>0) y+=(ph/8);					//trace("Random Y="+y+" X="+x);					//var y= Math.random()*ph-(ph/2);				//random starty					var pmh = ph/2;					var r = Math.sqrt(x*x+y*y);					var a = Math.asin(y/r);					var yy = Math.tan(a)*pw;					if(y>ph/2) y = ph/2;					if(y<-ph/2) y = - ph/2;					oy = sy = yy;					//trace("YY="+yy);					ax = (pages._xmouse<0)? -pw/2: pw/2;					var l = ((ph/2)-y);					ay = y+((Math.random()*2*l)-l)/2;				//page turnig style randomizing				}								pgmaskh = isCover(x)?coverBottom+coverTop+ph:ph;	//set the shadow height 					hit = 0;				if(x<0 && page>1) {//gminpage) {					//pages.flip.p3._x = 0;					hflip = (hcover && gskip)? (page==maxpage || gtarget==0): checkCover(page,-1);					ctear = p[pageNumber[page]].tear;					if(!(preflip && hflip)) {						if(gskip) setPages(gtarget,gtarget+1,page,page+1);						else setPages(page-2,page-1,page,page+1);					}					offs = -pw					fmask._x = pw;					hit = -1;				}				if(x>0 && page<gmaxpage) {					//pages.flip.p3._x = pw;					hflip = (hcover && gskip)? (page==0 || gtarget==maxpage): checkCover(page,1);					ctear = p[pageNumber[page+1]].tear;					if(!(preflip && hflip)) {						if(gskip) setPages(page,gtarget,page+1,gtarget+1);						else setPages(page,page+2,page+1,page+3);					}					offs = 0					fmask._x = 0;					hit = 1;				}				if(hflip && preflip) {					hit = 0;					preflip = false;					return false;				}				if(hit) {					//anim._visible = false;					flip = true;					flipOff = false;					ox = sx = hit*pw;					pp2.setMask(pages.mask0);					pp3.setMask(pages.mask1);					aadd = hit*(pw/10);	//hit*(pw/(gflip? 5:10 ));			//autoflip takes 10 frames to be done!!!					aflip = true;					if(preflip) {						oy = sy = (pages._ymouse<0)? -(ph/2): (ph/2);					}					r0 = Math.sqrt((sy+ph/2)*(sy+ph/2)+pw*pw);					r1 = Math.sqrt((ph/2-sy)*(ph/2-sy)+pw*pw);					oef();					return true;				}			} else return false;		}				function getm() {	//get x,y reference points depending of turning style: manual/auto			if(aflip && !preflip) {				x = ax;				y = ay;			} else {				x = pages._xmouse;				y = pages._ymouse;			}		}		function cgotoPage(i,skip) {			//if(i==9999) gotoPage(i);			gotoPage(getPN(i),skip);		}		function gotoPage(i,skip) {		//quickjump to the page number i			trace("gotoPage");			//			if(zoomMode) {//				hideZoom();//			}			if(i==9999) {				//thumbnails view				if(thEnabled) showThumbs();				return false;			}			//i = getRTLpn(getPN(i));				//i = target page			if(thMode) {				//in thumbnal mode, just show that page.				thExec(no);				return false;			}			gskip = (skip==undefined)? false: skip;	//skip pages						if(i<0) return false;			var p = int(page/2);		//current page			var d = int(i/2);			//target page			if(p!=d && canflip && !gflip) {		//target!=current page				if(p<d) {						//go forward					gdir = 1;					gpage = d-p-1;				} else {						//go backward					gdir = -1					gpage = p-d-1;				}				gflip = true;				if(gskip) gtarget = d*2, gpage = 0;				//startsnd(0);	//sound				onFlipStart(page,"GOTOPAGE");	//Event Handler ****				autoflip();			} else gskip = false;		}		function gotoPrevPage() {						trace("gotoPrevPage");			//gotoPage(pageNumber[page-2]);			gotoPage(page-2);		}		function gotoNextPage() {			//gotoPage(pageNumber[page+2]);			trace("gotoNextPage");			gotoPage(page+2);		}		function gotoLabel(lbl:String, skip:Boolean):Void{			gotoPage(getLabelPage(lbl), skip);		}		function getPN(i) {				//get the right page number			if(i==0) return 0;					var find = false;			for(j=1;j<=maxpage;j++) {				if(i==pageNumber[j]) {					i=j;					find = true;					break;				}			}			if(find || i==9999) return i;			else return -1;		//page Not found (it was removed previously)		}		function getRTLpn(pn) {			if(pn==9999) return pn;					//Thumbnail link does not changes			return RightToLeft?maxpage+1-pn:pn;		//RTL page number is reversed		}		function removePage(i) {			i = (Math.floor((i-1)/2)*2)+1;			//trace("remove page "+i);			removedPages.push(pageNumber[i], pageNumber[i+1]);			p[pageNumber[i]].item._visible = false;			p[pageNumber[i+1]].item._visible = false;			p[pageNumber[i]].page.reset(false,false);			p[pageNumber[i+1]].page.reset(false,false);				if(thCreated) {				thItems[i-gminpage].item.removeMovieClip();				thItems[i+1-gminpage].item.removeMovieClip();			}			for(var j=(i+2);j<=(maxpage+2);j++) {				pageNumber[j-2]=pageNumber[j];				if(thCreated) {					thItems[j-2-gminpage] = thItems[j-gminpage];				}			}			maxpage -= 2;			gmaxpage -= 2;		}				function testFileName(fn) {		//check if the page is embedded or not			var test = new Object();			var temp = fn.split(":");			if(temp[0]=="embedded") {				test.embedded = true;				test.name = temp[1];			} else {				test.embedded = false;				test.name = fn;			}			return test;		}		//-------------------------------------------resize stagePFScale = 100;		function resizepf():Void {			trace("resizepf");			if(PageScale) {				var pfxs = Stage.width/_root.BaseStageWidth*100;				var pfys = Stage.height/_root.BaseStageHeight*100;								//trace("BaseStageW/H "+_root.BaseStageWidth+"/"+_root.BaseStageHeight);				//trace("-- pfxs/pfys "+pfxs+"/"+pfys);								var sc:Number; 				sc = pfxs>pfys? pfys: pfxs;								if(sc>MaxScale) sc = MaxScale;								pages._xscale = sc				pages._yscale = sc;								PFScale = sc;								setPagesX();			}			zoomw = loadermc.zoomw;// ozoomw*sc/100;			zoomh = loadermc.zoomh;// ozoomh*sc/100;			if(zoomw==undefined) zoomw = Stage.width;			if(zoomh==undefined) zoomh = Stage.height;			if(thMode) {				thResize();				pagesScale = PFScale;			}			if(zoomMode) zoomResize();		}				function setPagesX() {			trace("setPagesX")			if(thMode) {				pages._x = OffsetX*PFScale/100;				pages._y = OffsetY*PFScale/100;			} else if(!VerticalMode) {				pages._x = (pagesOffsetX+OffsetX)*PFScale/100;				pages._y = OffsetY*PFScale/100;								if(BackContentFixed) {					pages.back._x = BCX - (pagesOffsetX+OffsetX);					pages.back._y = BCY - OffsetY;				}			} else {				pages._x = OffsetX*PFScale/100;				pages._y = (pagesOffsetX+OffsetY)*PFScale/100;								if(BackContentFixed) {					pages.back._x = BCX - OffsetX;					pages.back._y = BCY - (pagesOffsetX+OffsetY);				}			}		}						//-------------------------------------------thumbnail generatorthAct = false;thMode = false;thCreated = false;pagerOff = false;thPager = true;thPage = 0;thMaxpage = 0;thScale = 1;pagesScale = 0;thScrollDif = 0;thScroll = false;thScrollRoute = 0;//thBaseX = 0;//thBaseY = 0;//thXOffs = 0;//thYOffs = 0;thumbsMC = createEmptyMovieClip("thumbs",10100);thumbsMC._visible = false;thumbs = thumbsMC;		function showThumbs() {			trace("showThumbs")			if(thMode) {			//if thumbnail is already active				thMode = false;				threstartPF(page);	//restart pageflip				//trace("THUMBNAIL MODE OFF ------------------------------------");			} else {				onThumbnailsOn(page);		//Event handler ****				thMode = true;				ctrl.disableZoom();				ctrl.disablePrint();				thSetPagerText();				ctrl.disablepagerin();				ctrl.disableautoflipbtn();				pagerOff = true;				thPage = 0;				removeML();				delete onEnterFrame;				backVisible(false);								//-------------------------------------------------------------------------				//trace("THUMBNAIL MODE ON -------------------------------------");								if(LiveThumbnails) {											thSavePlaces();					startPageLoading();				}				// thumbnail display				thLayout();				if(!thLoaded && !LiveThumbnails) {		//load thumbnail files.					thLoaded = false;					thLcnt = RightToLeft? thItems.length-1: 0;					thLoadNext();				}				thumbs._visible = true;				onEnterFrame = function() {					//if needed scrolling is done here:					if(thScroll) {						var y = pfroot._ymouse;						y+= thScrollRoute/2;						if(y<0) y = 0;						if(y>thScrollRoute) y = thScrollRoute;						thumbs._y = -Math.floor((y/thScrollRoute)*thScrollDif);					}				}			}		}		function setShadows() {			var maxl = Math.sqrt(ph*ph+pw*pw);						fmask = pages.attachMovie("fmask","fmask",10000);	//arnyekok letrehozasa + maszkok			fmask.page.pf._width = pw;			fmask.page.pf._height = ph;			fgrad = pages.attachMovie("fgrad","fgrad",10001);			fgrad._yscale = 3*maxl;			fgrad.setMask(fmask);						pgmask = pages.attachMovie("pgmask","pgmask",10002);			pgmask._width = 2*pw;			pgmask._height = pgmaskh = ph;			pgrad = pages.attachMovie("pgrad","pgrad",10003);			pgrad._yscale = 3*maxl;			pgrad.setMask(pgmask);						pgmask2 = pages.attachMovie("pgmask","pgmask2",10004);			pgmask2._width = 2*pw;			pgmask2._height = ph;			p3shadow = pages.attachMovie("p3shadow","p3shadow",10005);			p3shadow._height = 3*maxl;			p3shadow.setMask(pgmask2);						pages.mask0._visible = false;			pages.mask1._visible = false;			pages.fgrad._visible = false;			pages.pgrad._visible = false;			pages.p3shadow._visible = false;						//set mask size			pages.mask0.maskbody._width = pages.mask1.maskbody._width = maxl;			pages.mask0.maskbody._height = pages.mask1.maskbody._height = 2*maxl;		}				function flipend() {			pp2.setMask(null);			pp3.setMask(null);			pages.fgrad._visible = false;			pages.pgrad._visible = false;			pages.p3shadow._visible = false;			//hardflip variables reset.			hflipend(hp2);			hflipend(hp3);		}				function hflipend(j) {			j.ph.pic.pic._x = 0;			j.ph.pic._rotation = 0;			j.ph.pic._xscale = 100;			j.ph.pic._yscale = 100;			j.ph._rotation = 0;			j.ph._xscale = 100;			j._yscale = 100;			j._x = 0;			j._y = 0;			j._visible = true;		}		function resetpage(i) {				//reset page position			p[pageNumber[i]].page._y = -ph/2;				}				function loadPage(i) {				//loading (creating a page)			if(p[i].mode == 0) {			//import page data from the Library				//trace("pagedata"+i+" import "+p[i].name);				p[i].page = p[i].loadTo.attachMovie(p[i].name,"pic",0);				resetpage(i);								p[i].pLoaded = true;		//next page can be loaded immedietly				p[i].loading = false;		//no need for waiting the load progress				p[pLoad].item._visible = false;	//default not visible				return true;				//initialize the page container			}			if(p[i].mode == 1) {			//load external page data 				p[i].page = p[i].loadTo.attachMovie("empty","pic",0);				p[i].page.loadMovie(p[i].name);				resetpage(i);				//initialize the page container								p[i].pLoaded = false;		//page is not yet loaded				p[i].loading = true;		//watch load progress				return false;			}		}		//---------------------------------------------------------------------------------//Ez a kod indul eloszor!!!//This part of code runs first!pages._visible = false;snd0 = new Sound();					//adding sound objectssnd1 = new Sound();snd2 = new Sound();setting_xml = new XML();				//XML flie loading/ XML fajl betoltesesetting_xml.onLoad = XMLparser;setting_xml.load(XMLfn);setting_xml.ignoreWhite = true;//-------------------------		function XMLparser(success) {						if (success == true) {				//XML file is successfully loaded, let's process data				var rootNode = setting_xml.firstChild;				var cnt = rootNode.childNodes.length;				var currentNode = rootNode.firstChild;								XML_TOCpage = 0;				XML_TOCs = new Array();								for(var i=0;i<cnt;i++) {		//fobb parameter tipusok					switch(currentNode.nodeName) {						case "Settings":							XMLgetSettings(currentNode);							break;						case "PageOrder":							XMLgetPageOrder(currentNode);							break;						case "Language":							XML_getLanguage(currentNode);							break;					}					currentNode = currentNode.nextSibling;				}				//Continue book building				CreatePageflip();							} else {				//Nem sikerult betolteni semmit									//Error - Nothing loaded				trace("Error loading XML file: "+XMLfn);				ctrl.loadertxt = "XML ERROR: CAN'T LOAD XML!";			}			delete setting_xml;		//delete temporary XML data		}				function XMLgetSettings(cNode) {		//beallitasok parameterei az XML-bol			//trace("set settings...");						pw = 				XML_Number(		cNode.attributes.PageWidth,					300);			ph = 				XML_Number(		cNode.attributes.PageHeight,				400);			hcover = 			XML_Boolean(	cNode.attributes.Hardcover,					false);			hardpage = 			XML_Boolean(	cNode.attributes.Hardpage,					false);			EmbossedPages = 	XML_Boolean(	cNode.attributes.EmbossedPages,				true);			rotz = 				XML_Number(		cNode.attributes.HcoverAngle,				-30); //-15;	//hardflip max y difference			clickarea = 		XML_Number(		cNode.attributes.ClickArea,					64);			afa = 				XML_Number(		cNode.attributes.AutoFlipArea,				56);			gs = 				XML_Number(		cNode.attributes.GotoPageSpeed,				2);			ps = 				XML_Number(		cNode.attributes.MouseFollowSpeed,			5);			es = 				XML_Number(		cNode.attributes.OnReleaseSpeed,			3);			tlimit = 			XML_Number(		cNode.attributes.TearDistance,				80); //80;		//tear distance			canflip = 			XML_Boolean(	cNode.attributes.FlippingEnabled,			true);			transparency = 		XML_Boolean(	cNode.attributes.TransparencyEnabled,		false);			transparencyAct =	XML_Boolean(	cNode.attributes.TransparencyActivePage,	false);									BackContent = 		XML_Boolean(	cNode.attributes.BackContent,				false);			BackFile = 			XML_String(		cNode.attributes.BackFile,					undefined);			BackActive = 		XML_Boolean(	cNode.attributes.BackActive,				false);			BackAlwaysVisible = XML_Boolean(	cNode.attributes.BackAlwaysVisible,			false);			BackContentFixed =	XML_Boolean(	cNode.attributes.BackContentFixed,			false);						BackgroundColor =	XML_Number(		cNode.attributes.BackgroundColor,			-1);			if(BackgroundColor==-1) BackgroundColor = undefined;			loadermc.setBackground(BackgroundColor);						buttonColor =		XML_Number(		cNode.attributes.buttonColor,				0x333333);			buttonOverColor =	XML_Number(		cNode.attributes.buttonOverColor,			0xF0B400);			buttonPressColor =	XML_Number(		cNode.attributes.buttonPressColor,			0x333333);			ctrl.btnCol = buttonColor;			ctrl.btnSelCol = buttonOverColor;			ctrl.btnPressCol = buttonPressColor;			ctrl.setColor();						mousehdl = 			XML_Boolean(	cNode.attributes.MouseControl,				true);			lcover = 			XML_Boolean(	cNode.attributes.LargeCover,				false);			if(lcover) {				coverTop =		XML_Number(		cNode.attributes.LargeCoverTopOversize,		0);			//Large Cover's top oversize				coverSide =		XML_Number(		cNode.attributes.LargeCoverSideOversize,	0);			//Large Cover's side oversize				coverBottom = 	XML_Number(		cNode.attributes.LargeCoverBottomOversize,	coverTop);	//Large Cover's bottom oversize			} else {				coverTop = 		0;				coverSide =		0;				coverBottom =	0;			}						startPage = 		XML_Number(		cNode.attributes.StartPage,					1);						AlwaysOpened =		XML_Boolean(	cNode.attributes.AlwaysOpened,				false);			if(AlwaysOpened && startPage<2) startPage=2;						CenterSinglePage =	XML_Boolean(	cNode.attributes.CenterSinglePage,			false);						pageAutoSize =		XML_Boolean(	cNode.attributes.AutoSize,					true);			UnloadPages =		XML_Boolean(	cNode.attributes.UnloadPages,				false);			startAF =			XML_Boolean(	cNode.attributes.startAutoFlip,				false);			AFInterval =		XML_Number( 	cNode.attributes.AutoFlipDefaultInterval,	2);			AFLoop =			XML_Boolean( 	cNode.attributes.AutoFlipLooping,			false);			PageCache =			XML_Number(		cNode.attributes.PageCache,					5);			//page loading on demand			RightToLeft =		XML_Boolean( 	cNode.attributes.RightToLeft,				false);			VerticalMode =		XML_Boolean( 	cNode.attributes.VerticalMode,				false);			if(VerticalMode) {				var temp = ph;				ph = pw;				pw = temp;			}						OffsetX =			XML_Number( 	cNode.attributes.OffsetX,					0);			OffsetY =			XML_Number( 	cNode.attributes.OffsetY,					0);						PageScale =			XML_Boolean( 	cNode.attributes.PageScale,					false);			if(PageScale) loadermc.resizeStage();			MaxScale =			XML_Number( 	cNode.attributes.MaxScale,					200);			BaseStageWidth =	XML_Number( 	cNode.attributes.BaseStageWidth,			Stage.width);			BaseStageHeight =	XML_Number( 	cNode.attributes.BaseStageHeight,			Stage.height);			_root.BaseStageWidth = BaseStageWidth;			_root.BaseStageHeight = BaseStageHeight;									PageLoaderBackColor = XML_Number(	cNode.attributes.PageLoaderBackColor,		0x000000);			PageLoaderColor = 	XML_Number(		cNode.attributes.PageLoaderColor,			0x000000);						PDFlink =			XML_String(		cNode.attributes.PDFlink,					undefined);			if(PDFlink!=undefined) ctrl.enablepdfbtn();						FullScreenEnabled = XML_Boolean( 	cNode.attributes.FullScreenEnabled,			true);			if(FullScreenEnabled) ctrl.enablefullscreenbtn();					ButtonHelp =		XML_Boolean(	cNode.attributes.ButtonHelp,				true);						LogoURL =			XML_String(		cNode.attributes.LogoURL,					undefined);			LogoLink =			XML_String(		cNode.attributes.LogoURL,					undefined);			zoomfs = 			XML_Number(		cNode.attributes.ZoomFollowSpeed,			5);			zoomAct = 			XML_Boolean(	cNode.attributes.ZoomActivePage,			false);			ZoomOnPageClick = 	XML_Boolean(	cNode.attributes.ZoomOnPageClick,			false);			LightBoxZoom = 		XML_Boolean(	cNode.attributes.LightBoxZoom,				false);			DragZoom =			XML_Boolean(	cNode.attributes.DragZoom,					false);			ZoomToTop =			XML_Boolean(	cNode.attributes.ZoomToTop,					false);			zoomHotspot =		XML_Boolean(	cNode.attributes.ZoomHotspot, 				true);			thEnabled =			XML_Boolean(	cNode.attributes.ThumbnailsEnabled,			true);						LiveThumbnails = 	XML_Boolean(	cNode.attributes.LiveThumbnails,			true);			//ThumbnailScale = 	XML_Boolean(	cNode.attributes.ThumbnailScale,			false);			//ThumbnailFixedSize = XML_Boolean( cNode.attributes.ThumbnailFixedSize,		false);			ThumbnailWidth = 	XML_Number(		cNode.attributes.ThumbnailWidth,			0);			ThumbnailHeight = 	XML_Number(		cNode.attributes.ThumbnailHeight,			0);			thAct =				XML_Boolean(	cNode.attributes.ThumbnailsActivePages,		false);			thPadding = 		XML_Number(		cNode.attributes.ThumbnailPadding,			16);			thBorder = 			XML_Number(		cNode.attributes.ThumbnailBorderWidth,		0.5);			thBorderColor = 	XML_Number(		cNode.attributes.ThumbnailBorderColor,		0x000000);			thBorderHColor = 	XML_Number(		cNode.attributes.ThumbnailBorderHoverColor,	0x000000);						var cnt = cNode.childNodes.length;			if(cnt) {				//trace("Setting has childnode(s)");				var subNode = cNode.firstChild;				for(var i=0;i<cnt;i++) {					//trace("Parsing setting's childnode");				//	if(subNode.nodeName=="Sounds") XMLgetSounds(subNode);					subNode = subNode.nextSibling;				}			}		}						function XMLgetPageOrder(cNode) {		//Oldalak beallitasa XML parameterek alapjan			//trace("set pageOrder...");			XML_pageOrder = new Array();			XML_zoomname = new Array();			XML_caption = new Array();			XML_printname = new Array();			XML_thFiles = new Array();			XML_pageTear = new Array();			XML_pageLabels = new Array();			XML_pageName = new Array();			XML_isHard = new Array();			XML_hotspotData = new Array();			XML_data = new Array();			XML_label = new Array();			XML_page = 0;						var subNode = cNode.firstChild;			var cnt = cNode.childNodes.length;			if(cnt) {				for(var i=0;i<cnt;i++) {					//trace("Adding page information");					if(subNode.nodeName=="PageData") {						XML_page++;						XML_pageOrder[XML_page]		= 	XML_String(		subNode.attributes.PageFile			);						XML_zoomname[XML_page]		= 	XML_String(		subNode.attributes.ZoomFile,		"");						XML_printname[XML_page]		= 	XML_String(		subNode.attributes.PrintFile,		"");							var largefile			= 	XML_String(		subNode.attributes.LargeFile,		"");							if(largefile) XML_zoomname[XML_page] = XML_printname[XML_page] = largefile;						XML_caption[XML_page]		= 	XML_String(		subNode.attributes.Caption,			"");						XML_pageTear[XML_page]		=	XML_Boolean(	subNode.attributes.TearOff,			false);						XML_isHard[XML_page]		=	XML_Boolean(	subNode.attributes.HardPage,		false);						XML_pageName[XML_page]		= 	XML_String(		subNode.attributes.PageName,		undefined);						XML_thFiles[XML_page]		= 	XML_String(		subNode.attributes.ThumbnailFile	);						XML_hotspotData[XML_page]	=	XML_String(		subNode.attributes.HotspotData, 	"");						XML_data[XML_page]			= 	XML_String(		subNode.attributes.Data,			"");						XML_label[XML_page]			= 	XML_String(		subNode.attributes.Label,			undefined);												/*						if(subNode.attributes.Label != null) {		//if label is set, push it 							XML_pageLabels.push({label: XML_String(subNode.attributes.Label), targetpage: XML_page});						}						*/					}					subNode = subNode.nextSibling;				}				maxpage = XML_page;			}		}		function gotoPageLabel(label, Skip) {		//go to a page with label			//trace("GOTOLABEL "+label);			for(var i=0; i<p.length; i++) {				if(p[i].label == label) {					//trace("label found on page "+p[i].no);					var targetpage = p[i].no;					cgotoPage(targetpage, Skip);					return targetpage;				}			}			return -1;		}				function XML_getLanguage(cNode) {			SoundLoadingText =					XML_String(		cNode.attributes.SoundLoadingText,					"Loading sounds #");			ZoomLoadingText =					XML_String(		cNode.attributes.ZoomLoadingText,					"Loading zoom page #");			PrintLoadingText =					XML_String(		cNode.attributes.PrintLoadingText,					"Loading print page #");				PreviousPageButtonHelp =			XML_String(		cNode.attributes.PreviousPageButtonHelp,			"Flip backward 1 page");			NextPageButtonHelp =				XML_String(		cNode.attributes.NextPageButtonHelp,				"Flip forward 1 page");			ZoomLeftButtonHelp =				XML_String(		cNode.attributes.ZoomLeftButtonHelp,				"Zoom left side page");			ZoomRightButtonHelp =				XML_String(		cNode.attributes.ZoomRightButtonHelp,				"Zoom right side page");			PrintLeftButtonHelp =				XML_String(		cNode.attributes.PrintLeftButtonHelp,				"Print left side page");			PrintRightButtonHelp =				XML_String(		cNode.attributes.PrintRightButtonHelp,				"Print right side page");			ThumbnailButtonHelp =				XML_String(		cNode.attributes.ThumbnailButtonHelp,				"Thumbnail view");			FullScreenOnButtonHelp =			XML_String(		cNode.attributes.FullScreenOnButtonHelp,			"Exit fullscreen mode")			FullScreenOffButtonHelp =			XML_String(		cNode.attributes.FullScreenOffButtonHelp,			"Switch to fullscreen mode")			PDFButtonHelp =						XML_String(		cNode.attributes.PDFButtonHelp,						"Download this book in pdf format");			StartAutoFlipHelp =					XML_String(		cNode.attributes.StartAutoFlipHelp,					"Start auto flipping");			StopAutoFlipHelp =					XML_String(		cNode.attributes.StopAutoFlipHelp,					"Stop auto flipping");							PagerText =							XML_String(		cNode.attributes.PagerText,							"Page #");  			ZoomPagerText =						XML_String(		cNode.attributes.ZoomPagerText,						"Zoom page #");			ThumbnailPagerSingle =				XML_String(		cNode.attributes.ThumbnailPagerSingle,				"Thumbnails");			ThumbnailPager =					XML_String(		cNode.attributes.ThumbnailPager,					"Thumbs #");			ThumbnailPreviousPageButtonHelp =	XML_String(		cNode.attributes.ThumbnailPreviousPageButtonHelp,	"Previous page");			ThumbnailNextPageButtonHelp =		XML_String(		cNode.attributes.ThumbnailNextPageButtonHelp,		"Next page");			CopyrightText =						XML_String(		cNode.attributes.CopyrightText,						"");						ctrl.credits.creditsin.htmlText = CopyrightText;			//trace("---> "+ctrl.credits.creditsin);		}				//parsing variables by type - valtozok ertelmezese tipus szerint		function XML_Boolean(att,def) {			if(def!=undefined && att==null) {				return def;			}			if(att=="true") return true;			else return false;		}		function XML_Number(att,def) {			if(def!=undefined && att==null) {				return def;			}			return Number(att);		}		function XML_String(att,def) {			if(def!=undefined && att==null) {				return def;			}			if(att==undefined) return undefined;			return String(att);		}		function XML_lang(str, ins) {			if(ins != undefined) {				var strparts = str.split("#")				return strparts[0]+ins+strparts[1];			} else {				return str;			}		}				function setMultiloaderbar(div, no, pc) {			if(pc>0) {			} else pc=0;			var mpcm = 100/div;			var mpc = no*mpcm;			mpc += mpcm*(pc/100);			if(no>=div) mpc=100;			return mpc;		}var firstStart:Boolean = False;		function firstStartPF() {			firstStart = true;			reset(maxpage);			startPF();		//here starts the PF!		}		function startPF() {		//start the pageflip engine			pages._rotation = VerticalMode? 90: 0;			if(!firstStart) resetPages();						if(mousehdl) Mouse.addListener(mousecontroll);			ctrl.enablethumbsbtn();			ctrl.enableautoflipbtn();			ctrl.enablepagerin();			ctrl.setloader(0);			ctrl.setpager();			onEnterFrame = function() {	//Master onEnterFrame function				oef();		//main function: handles page turning -------------				if(canloadpages && pagesready) {					canloadpages = false;					resizepf();					resetPages();					firstStart = false;					startPageLoading();					pages._visible = true;					if(startAF) {						startAutoFlip();						ctrl.autoflipbtn.alt = true;						ctrl.autoflipbtn.gotoAndStop(2);						ctrl.autoflipbtn.gotoAndStop(1);											}				}			}			gotoAndStop("start");		}		// Pageflip creation ----------------------------------------------------------		function CreatePageflip() {				//Creates a working, self loading pageFlip			pagesready = false;			if(XML_page==undefined || XML_page<1) {		//If no pages were defined, don't start at all				XML_page = maxpage = 0;				ctrl.loadertxt = "XML ERROR: NO PAGES TO LOAD!";				return;			}			CreatePages();						//if loaded -> go to create pages			setShadows();			if(directlink>0 && directlink<=gmaxpage) {				startPage = directlink;			}			if(RightToLeft) startPage = maxpage-startPage+1;	//gmaxpage???			page = Math.floor(startPage/2)*2;	//first page (normally it is 0 = the page before the cover = blank page)			if(BackContent) loadBack();			canloadpages = true;				//let's load the content					//	if(SoundOn) loadSounds();				//else 			firstStartPF();		}		function CreatePages() {			//Create the page objects of the book			p = new Array();				//define page content			gminpage = AlwaysOpened?2:1;	//set the first visible page depending on the book style AlwaysOpened			maxpage = XML_page+gminpage-1;	//set also the last page depending on it			gmaxpage = maxpage;				//last visible page			maxpage += maxpage%2;			//set maxpage for later calculations						if(RightToLeft) {				//if the book is in RTL mode, we have to recalculate our variables				if(gmaxpage%2==1) {					if(gminpage==1) i = maxpage, gminpage = 2;					else i = maxpage-1, gminpage = 2, gmaxpage-=1;				} else {					if(gminpage==1) i = maxpage;					else i = maxpage-1, gminpage = 1, gmaxpage-=1;				}			} else i = gminpage;			pNum = 1;	//page numbering start, can be overwritten from xml: pageName="*5" -> will start page numbering from 5;						for(var j=1; j<=gmaxpage ;j++) {				var isCover = (i<3) || (i>maxpage-2);				p[i] = pageData(i, XML_pageOrder[j], XML_zoomname[j], XML_caption[j], XML_printname[j], XML_pageName[j], XML_thFiles[j], XML_pageTear[j], XML_isHard[j], XML_hotspotData[j], XML_data[j], XML_label[j], isCover);				i += RightToLeft? -1: 1;				pNum++;			}					}				function pageData(i, name, zoomname, caption, printname, pageName, thFile, tear, isHard, hotspot, data, label, isCover) {		//return page object			var obj = new Object();						//trace("****PAGE "+i+" label "+label);			obj.no = i;			obj.name = name;			obj.zoomname = zoomname;			obj.caption = caption;			obj.printname = printname;			obj.tear = tear;			obj.hotspot = hotspot;			obj.data = data;			obj.label = label;			obj.isCover = isCover;			obj.isHard = isHard;						if(pageName!=undefined) {				if(pageName.charAt(0)=="*") {					//trace("*");					var n = Number(pageName.substr(1));					pNum = isNaN(n) ? 1: n;					obj.pageNumber = pNum;				} else obj.pageName = pageName;			} else obj.pageNumber = pNum;						obj.thFile = thFile;						obj.pLoaded = false;			obj.loading = false;						obj.item = pages.attachMovie("mainpage","p"+i,i);			obj.item._x = (i%2==0)? 0: pw;			obj.item.page._x = -pw;						//pozicio beallitas			obj.loadTo = obj.item.page.pf.sph.ph.pic;	//ide jonnek az oldalak!						obj.page = obj.loadTo.attachMovie("pageContainer","pic",0);			obj.page._y = -ph/2;			obj.page.no = i;			obj.page.name = name;			obj.page.zoomname = zoomname;			obj.page.caption = caption;			obj.page.printname = printname;			obj.page.hotspot = hotspot;			obj.page.data = data;			obj.page.label = label;			obj.page.isCover = isCover;			obj.page.isHard = isHard;			obj.page.pageName = obj.pageName;			obj.page.pageNumber = obj.pageNumber;			obj.page.thFile = thFile;						obj.item._visible = false;	//default not visible						//trace("PageName:   "+obj.pageName);			//trace("PageNumber: "+obj.pageNumber);			//trace("-----------------------------");						return obj;		}		//Back loader ------------------------------------------------------------------BCX = 0;BCY = 0;		function loadBack() {			var test = testFileName(BackFile);			if(test.embedded) {				pages.back.attachMovie(test.name, "content", 0);			} else {							var backloadListener:Object = new Object();				backloadListener.onLoadComplete = function(target:MovieClip, httpStatus:Number):Void {				}				backloadListener.onLoadInit = function(target:MovieClip):Void {					backVisible(true);					var bw = pages.back._width;					var bh = pages.back._height;					if(pages.back.Width!=undefined) bw = pages.back.Width;					if(pages.back.Height!=undefined) bh = pages.back.Height;					pages.back._x = BCX = -bw/2;					pages.back._y = BCY = -bh/2;				}				backloadListener.onLoadError = function(target_mc:MovieClip, errorCode:String, httpStatus:Number) {					BackContent = false;				}				backloadListener.onLoadProgress = function(target:MovieClip, LB:Number, TB:Number):Void {				}							var backLoader:MovieClipLoader = new MovieClipLoader();				backLoader.addListener(backloadListener);				backLoader.loadClip(BackFile, pages.back);			}		}		function backVisible(stat) {			pages.back._visible = BackContent&stat;		}//page loading on demand -------------------------------------------------------		var lploading:Boolean = false;var lpage:Number = -1;var lpdcnt:Number = 0;var lpucnt:Number = 1;var unloading:Boolean = false;				function startPageLoading() {		//loads page content from actual page +/- pageCache			var i:Number = page-page%2;			lpage = i;			lpdcnt = 0;			lpucnt = 0;			unloading = false;			if(!lploading) {				//do nothing if already loading				lploading = true;				loadNextPage();				if(lcover) {					if(!p[pageNumber[2]].pLoaded) p[pageNumber[2]].page.loadPage(false);									if(!p[pageNumber[maxpage-1]].pLoaded) p[pageNumber[maxpage-1]].page.loadPage(false);								}			}		}		function loadNextPage() {			//load the next page			var loading = false;			while(!loading) {				var i:Number = getnext();				//trace("LOADPAGE: "+i);				if(!p[pageNumber[i]].pLoaded || unloading) {					if(i>=gminpage && i<=gmaxpage) {		//gmaxpage?						if(!unloading) {							loading = p[pageNumber[i]].page.loadPage(true);						} else {							if(!(lcover && (i==2 || i==maxpage-1))) p[pageNumber[i]].page.unloadPage();						}					} else lploading = false, loading = true;				}			}		}				function getnext() {				//find the next page to load			var np:Number = -1;			while (np<0) {				if(lpdcnt>lpucnt) {					lpucnt++;					if(lpage+lpucnt<=gmaxpage) np = lpage+lpucnt;				} else {					var cnt = lpdcnt;					lpdcnt++;					if(cnt>=PageCache && !thMode) unloading=true;					if(cnt>gmaxpage) np = 0;					if(lpage-cnt>=gminpage) np = lpage-cnt;				}			}			return np;		}// auto fliping controls -------------------------------------------------------------------var aflipstat:Boolean = false;var afliploop:Boolean = false;		function toggleAutoFlip (sec, loop) {	//start/stop auto fliping			if(aflipstat) stopAutoFlip();			else {				startAutoFlip(sec, loop);				autoNextPage();			}			return aflipstat;		}		function startAutoFlip (sec, loop) {	//start auto fliping			ctrl.disablethumbsbtn();			ctrl.disablepagerin();			ctrl.disablePager();			aflipstat = true;			ctrl.setpager();			afliploop = loop==undefined? AFLoop: loop;			if(sec==undefined) sec = AFInterval;	// 2 seconds			intervalID = setInterval(autoNextPage,sec*1000);		}		function stopAutoFlip () {				//stop auto fliping			ctrl.enablethumbsbtn();			ctrl.enablepagerin();			//ctrl.enablePager();			aflipstat = false;			clearInterval(intervalID);			ctrl.setpager();		}		function autoNextPage() {				//get the next page			if(!RightToLeft) {				if(gmaxpage<=(page)) {					if(afliploop) gotoPage(1, true);					else stopAutoFlip();				} else gotoNextPage();			} else {				if(page<=0) {					if(afliploop) gotoPage(gmaxpage, true);					else stopAutoFlip();				} else gotoPrevPage();							}		}// EVENT HANDLERS --- USE THESE FUNCTION TO CATCH AN EVENT ---------------------------------		function onFlipStart(page, eventMessage) {			//trace("Flip started on page "+page+" message: "+eventMessage);			}		function onFlipEnd(page, eventMessage) {			//trace("Flip ended on page "+page+" message: "+eventMessage);			}		function onTearOut(page, eventMessage) {			//trace("Page "+page+" torn out message: "+eventMessage);			}		function onZoomIn(page) {			//trace("Zoom in page "+page);			} 		function onZoomOut(page) {			//trace("Zoom out page "+page);			} 		function onThumbnailsOn(page) {			//trace("Thumbnail mode on "+page);			} 		function onThumbnailsOff(page) {			//trace("Thumbnail mode off "+page);			} 